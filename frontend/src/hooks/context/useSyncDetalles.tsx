import { useEffect } from "react";
import { useFormikContext } from "formik";
import type { CobranzasFormValues, DeudasPendientesResponse } from "../../types/types";
import isEqual from "lodash/isEqual";
import { normalizeInscripcion } from "../../funcionalidades/pagos/PagosFormulario";
import { useInscripcionesActivas } from "../../hooks/useInscripcionesActivas";

// Función auxiliar para generar detalles autogenerados a partir de deudaData
const getNewAutoDetails = (
  deudaData: DeudasPendientesResponse,
  ultimoPago: any
) => {
  const autoFromPagos =
    deudaData.pagosPendientes?.flatMap((pago) =>
      pago.detallePagos?.map((det) => ({
        autoGenerated: true,
        // Si existe último pago se usa el id; de lo contrario, se fuerza a null.
        id: ultimoPago ? det.id : null,
        concepto: det.concepto,
        // Se utiliza la nueva propiedad "montoOriginal"
        montoOriginal: det.montoOriginal,
        importe: det.importe,
        aCobrar: det.aCobrar,
      })) || []
    ) || [];

  const autoFromMensualidades =
    deudaData.mensualidadesPendientes?.flatMap((mens) =>
      mens.totalPagar > 0
        ? [
            {
              autoGenerated: true,
              id: ultimoPago ? mens.id : null,
              concepto: mens.descripcion,
              // Se mapea "valorBase" de mensualidad a "montoOriginal" para homogeneidad
              montoOriginal: mens.valorBase,
              importe: mens.totalPagar,
              aCobrar: mens.totalPagar,
            },
          ]
        : []
    ) || [];

  return [...autoFromPagos, ...autoFromMensualidades];
};

export const useSyncDetalles = (
  deudaData: DeudasPendientesResponse,
  ultimoPago: any
) => {
  const { values, setFieldValue } = useFormikContext<CobranzasFormValues>();
  const inscripcionesQuery = useInscripcionesActivas(Number(values.alumnoId));

  useEffect(() => {
    // 1. Obtener los nuevos detalles autogenerados
    const newAutoDetails = getNewAutoDetails(deudaData, ultimoPago);

    // 2. Filtrar los que hayan sido eliminados por el usuario
    const removedIds = new Set(values.autoRemoved || []);
    const autoDetailsNotRemoved = newAutoDetails.filter((detalle) => {
      if (detalle.id !== null) {
        return !removedIds.has(detalle.id) && Number(detalle.importe) !== 0;
      }
      return Number(detalle.importe) !== 0;
    });

    // 3. Separar los detalles manuales (los modificados por el usuario)
    const manualDetails = values.detallePagos.filter(
      (detalle) => !detalle.autoGenerated
    );

    // 4. Para los detalles con id (no nulos), evitamos duplicados con los manuales
    const manualIdentifiers = new Set(
      manualDetails
        .filter((detalle) => detalle.id !== null)
        .map((detalle) => detalle.id)
    );

    // 5. Filtrar los nuevos detalles autogenerados:
    //    - Si tienen id, se omiten si ya existe un manual con ese id.
    //    - Si no tienen id, se verifica si ya existe un manual que coincida en 'concepto' y 'montoOriginal'.
    const finalAutoDetails = autoDetailsNotRemoved.filter((autoDet) => {
      if (autoDet.id !== null) {
        return !manualIdentifiers.has(autoDet.id);
      } else {
        const existsManual = manualDetails.some(
          (manDet) =>
            manDet.concepto === autoDet.concepto &&
            manDet.montoOriginal === autoDet.montoOriginal
        );
        return !existsManual;
      }
    });

    // 6. Fusionar los detalles manuales con los autogenerados filtrados
    const mergedDetails = [...manualDetails, ...finalAutoDetails];

    // 7. Actualizar el formulario solo si hay diferencias
    if (!isEqual(mergedDetails, values.detallePagos)) {
      console.log("[useSyncDetalles] Actualizando detallePagos:", mergedDetails);
      setFieldValue("detallePagos", mergedDetails);
    }

    // 8. Sincronizar la inscripción si es dummy (id === -1)
    if (values.inscripcion.id === -1) {
      let inscripcionValida = null;
      // Buscar inscripción en pagos pendientes
      if (deudaData.pagosPendientes && deudaData.pagosPendientes.length > 0) {
        const pagoConInscripcion = deudaData.pagosPendientes.find(
          (pago) => pago.inscripcion != null
        );
        if (pagoConInscripcion) {
          inscripcionValida = pagoConInscripcion.inscripcion;
          console.log("[useSyncDetalles] Inscripción encontrada en pago:", inscripcionValida);
        }
      }
      // Si no se encontró, buscar en mensualidades pendientes
      if (!inscripcionValida && deudaData.mensualidadesPendientes && deudaData.mensualidadesPendientes.length > 0) {
        const mensConInscripcionId = deudaData.mensualidadesPendientes.find(
          (mens) => mens.inscripcionId && mens.inscripcionId !== 0
        );
        if (mensConInscripcionId && inscripcionesQuery.data) {
          const insc = inscripcionesQuery.data.find(
            (ins) => ins.id === mensConInscripcionId.inscripcionId
          );
          if (insc) {
            inscripcionValida = insc;
            console.log("[useSyncDetalles] Inscripción encontrada en mensualidad:", inscripcionValida);
          }
        }
      }
      if (inscripcionValida) {
        const normalized = normalizeInscripcion(inscripcionValida);
        console.log("[useSyncDetalles] Asignando inscripción normalizada:", normalized);
        setFieldValue("inscripcion", normalized);
      } else {
        console.log("[useSyncDetalles] No se encontró inscripción válida en deudaData");
      }
    }
  }, [
    deudaData,
    ultimoPago,
    setFieldValue,
    values.alumnoId,
    values.detallePagos,
    values.autoRemoved,
    inscripcionesQuery.data,
    values.inscripcion,
  ]);
};
