import { useEffect } from "react";
import { useFormikContext } from "formik";
import type {
  CobranzasFormValues,
  DetallePagoRegistroRequestExt,
  DetallePagoResponse,
  AlumnoDataResponse,
} from "../../types/types";

// Función para separar concepto y cuota usando una expresión regular que soporte varios tipos de guión
const splitConceptAndCuota = (
  text: string
): { concept: string; cuota: string } => {
  if (!text) return { concept: "", cuota: "" };
  const parts = text.split("-");
  if (parts.length < 2) {
    return { concept: text.trim(), cuota: "" };
  }
  return {
    concept: parts[0].trim(),
    cuota: parts.slice(1).join("-").trim(),
  };
};

const mapDetallePagos = (
  detallesPendientes: DetallePagoResponse[],
  alumnoData: AlumnoDataResponse
): DetallePagoRegistroRequestExt[] => {
  // Tomamos el saldo a favor del alumno
  let creditoRestante = Number(alumnoData.alumno?.creditoAcumulado || 0);

  return detallesPendientes.map((det) => {
    // El importe base de este detalle
    let baseValue = det.importePendiente ?? 0;

    // Si es una 'MATRICULA' y aún tenemos saldo a favor, restamos
    if (
      det.descripcionConcepto?.toUpperCase().includes("MATRICULA") &&
      creditoRestante > 0
    ) {
      const nuevoValor = Math.max(0, baseValue - creditoRestante);
      baseValue = nuevoValor;
    }

    return {
      autoGenerated: true,
      id: det.id,
      version: det.version,
      descripcionConcepto: det.descripcionConcepto || "",
      conceptoId: det.conceptoId ?? null,
      subConceptoId: det.subConceptoId ?? null,
      // Si cuotaOCantidad es nulo, usamos la parte extraída; de lo contrario, usamos el valor existente
      cuotaOCantidad:
        det.cuotaOCantidad ??
        (splitConceptAndCuota(det.descripcionConcepto || "").cuota || "1"),
      valorBase: det.valorBase ?? 0,
      bonificacionId: det.bonificacionId ?? null,
      recargoId: det.recargoId ?? null,
      importePendiente: baseValue,
      ACobrar: baseValue,
      cobrado: det.cobrado ?? false,
      mensualidadId: det.mensualidadId ?? null,
      matriculaId: det.matriculaId ?? null,
      importeInicial: det.importeInicial ?? 0,
      stockId: det.stockId ?? null,
      pagoId: det.pagoId ?? null,
      tieneRecargo: det.tieneRecargo,
      estadoPago: det.estadoPago,
      removido: det.removido,
      alumno: alumnoData.alumno,
    };
  });
};

export const useSyncDetalles = (alumnoData: AlumnoDataResponse | undefined) => {
  const { setFieldValue } = useFormikContext<CobranzasFormValues>();

  useEffect(() => {
    if (!alumnoData) return;

    const detallesPendientes =
      alumnoData.detallePagosPendientes || alumnoData.detallePagos || [];

    const autoDetails = mapDetallePagos(detallesPendientes, alumnoData);

    const autoDetailsFiltered = autoDetails.filter(
      (det) => Number(det.importePendiente) > 0
    );

    setFieldValue("detallePagos", autoDetailsFiltered);
    setFieldValue("autoRemoved", []);
  }, [alumnoData, setFieldValue]);

  useEffect(() => {
    if (!alumnoData) return;

    const detallesPendientes =
      alumnoData.detallePagosPendientes || alumnoData.detallePagos || [];
    const nuevoReciboNro =
      detallesPendientes.length > 0 ? detallesPendientes[0].pagoId || 0 : 0;
    setFieldValue("reciboNro", nuevoReciboNro);
  }, [alumnoData, setFieldValue]);
};
