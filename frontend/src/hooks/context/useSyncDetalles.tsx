// src/hooks/useSyncDetalles.ts
import { useEffect, useRef } from "react";
import { useFormikContext } from "formik";
import isEqual from "lodash/isEqual";
import type {
  CobranzasFormValues,
  DetallePagoRegistroRequest,
  DetallePagoRegistroRequestExt,
  DetallePagoResponse,
  AlumnoDataResponse,
} from "../../types/types";

/**
 * Función de mapeo que transforma cada detalle pendiente obtenido (DetallePagoResponse)
 * al formato que utiliza el formulario.
 */
const mapDetallePagos = (
  detallePendientes: DetallePagoResponse[],
  currentDetalles: DetallePagoRegistroRequest[]
): DetallePagoRegistroRequestExt[] => {
  console.log(
    "[mapDetallePagos] Iniciando mapeo de detalles pendientes:",
    detallePendientes
  );
  return detallePendientes.map((det) => {
    // Se utiliza 'mensualidadId' si existe, de lo contrario se utiliza 'id'
    const idKey = det.mensualidadId ?? det.id;
    console.log(`[mapDetallePagos] Procesando detalle con idKey: ${idKey}`);

    // Buscar si ya existe un detalle en el formulario
    // que tenga ese idKey o un pagoId coincidente
    const existing = currentDetalles.find(
      (d) => d.id === idKey || (d.pagoId != null && d.pagoId === det.pagoId)
    );
    if (existing) {
      console.log(
        `[mapDetallePagos] Se encontró detalle existente para id ${idKey}:`,
        existing
      );
    } else {
      console.log(
        `[mapDetallePagos] No se encontró detalle existente para id ${idKey}`
      );
    }

    // Si ya existe y no es autoGenerated, se respeta el valor manual de aCobrar;
    // de lo contrario, se asigna el mismo valor que importePendiente.
    const aCobrarValue =
      existing && !existing.autoGenerated
        ? existing.aCobrar
        : det.importePendiente ?? 0;

    const mappedDetail: DetallePagoRegistroRequestExt = {
      // Si existe el detalle en el formulario, se conserva su flag; de lo contrario, se marca como autogenerado.
      autoGenerated: existing ? existing.autoGenerated : true,
      id: det.id, // Conservamos el id original del detalle
      version: det.version,
      descripcionConcepto: det.descripcionConcepto || "",
      conceptoId: det.conceptoId ?? null,
      subConceptoId: det.subConceptoId ?? null,
      cuotaOCantidad: det.cuotaOCantidad ?? "1",
      valorBase: det.valorBase ?? 0,
      bonificacionId: det.bonificacionId ?? null,
      recargoId: det.recargoId ?? null,
      importePendiente: det.importePendiente,
      aCobrar: aCobrarValue,
      cobrado: det.cobrado ?? false,
      mensualidadId: det.mensualidadId ?? null,
      matriculaId: det.matriculaId ?? null,
      stockId: det.stockId ?? null,
      pagoId: det.pagoId ?? null,
    };
    console.log("[mapDetallePagos] Detalle mapeado:", mappedDetail);
    return mappedDetail;
  });
};

/**
 * Hook para sincronizar los detalles de pago del formulario con los detalles pendientes
 * obtenidos en AlumnoDataResponse.
 *
 * Este hook se ejecuta únicamente cuando cambia el objeto alumnoData, evitando re-sincronizaciones
 * que sobrescriban modificaciones manuales en el formulario.
 */
export const useSyncDetalles = (alumnoData: AlumnoDataResponse | undefined) => {
  const { values, setFieldValue } = useFormikContext<CobranzasFormValues>();
  // Usamos un ref para indicar si ya se realizó la sincronización inicial.
  const initialSyncDone = useRef(false);

  useEffect(() => {
    console.log("[useSyncDetalles] Iniciando sincronización...");
    if (!alumnoData) {
      console.log(
        "[useSyncDetalles] No hay alumnoData. Abortando sincronización."
      );
      return;
    }

    // Solo sincronizamos si no se ha realizado la sincronización inicial.
    if (initialSyncDone.current) {
      console.log(
        "[useSyncDetalles] Sincronización ya realizada previamente. No se actualiza."
      );
      return;
    }

    console.log("[useSyncDetalles] AlumnoData recibido:", alumnoData);
    console.log(
      "[useSyncDetalles] Valores actuales del formulario (detallePagos):",
      values.detallePagos
    );
    console.log(
      "[useSyncDetalles] Valores actuales del formulario (autoRemoved):",
      values.autoRemoved
    );

    // 1. Mapear los detalles pendientes del backend al formato del formulario.
    const autoDetails = mapDetallePagos(
      alumnoData.detallePagosPendientes || [],
      values.detallePagos
    );
    console.log(
      "[useSyncDetalles] Detalles automáticos mapeados:",
      autoDetails
    );

    // 2. Filtrar los detalles removidos manualmente.
    const removedIds = new Set(values.autoRemoved || []);
    const autoDetailsFiltered = autoDetails.filter((det) => {
      if (det.id != null) {
        const include =
          !removedIds.has(det.id) && Number(det.importePendiente) > 0;
        console.log(
          `[useSyncDetalles] Auto detalle id=${det.id} ${
            include ? "incluido" : "excluido"
          } por removedIds (${removedIds.has(det.id)}) y importePendiente (${
            det.importePendiente
          })`
        );
        return include;
      }
      const include = Number(det.importePendiente) > 0;
      console.log(
        `[useSyncDetalles] Auto detalle sin id ${
          include ? "incluido" : "excluido"
        } por importePendiente (${det.importePendiente})`
      );
      return include;
    });
    console.log(
      "[useSyncDetalles] Detalles automáticos filtrados:",
      autoDetailsFiltered
    );

    // 3. Extraer los detalles manuales presentes en el formulario (no autogenerados).
    const manualDetails = values.detallePagos.filter(
      (det) => !det.autoGenerated
    );
    console.log("[useSyncDetalles] Detalles manuales actuales:", manualDetails);

    // 4. Fusionar manuales y automáticos, evitando duplicados.
    let mergedDetails: DetallePagoRegistroRequestExt[];
    if (manualDetails.length > 0) {
      const manualIds = new Set(
        manualDetails.filter((det) => det.id != null).map((det) => det.id)
      );
      console.log(
        "[useSyncDetalles] IDs de detalles manuales:",
        Array.from(manualIds)
      );
      const finalAutoDetails = autoDetailsFiltered.filter((autoDet) => {
        if (autoDet.id != null) {
          const include = !manualIds.has(autoDet.id);
          if (!include) {
            console.log(
              `[useSyncDetalles] Auto detalle id=${autoDet.id} descartado porque ya existe manual.`
            );
          }
          return include;
        }
        const exists = manualDetails.some(
          (manDet) =>
            manDet.descripcionConcepto === autoDet.descripcionConcepto &&
            manDet.valorBase === autoDet.valorBase
        );
        if (exists) {
          console.log(
            "[useSyncDetalles] Auto detalle sin id descartado por coincidencia de campos:",
            autoDet
          );
        }
        return !exists;
      });
      console.log(
        "[useSyncDetalles] Detalles automáticos finales después de filtrar duplicados:",
        finalAutoDetails
      );
      mergedDetails = [...manualDetails, ...finalAutoDetails];
      console.log(
        "[useSyncDetalles] Fusionando manuales y automáticos no duplicados:",
        mergedDetails
      );
    } else {
      mergedDetails = autoDetailsFiltered;
      console.log(
        "[useSyncDetalles] No hay detalles manuales; usando automáticos:",
        mergedDetails
      );
    }

    // 5. Actualizar el formulario si la lista final difiere.
    if (!isEqual(mergedDetails, values.detallePagos)) {
      console.log(
        "[useSyncDetalles] La lista final difiere de la actual. Actualizando 'detallePagos' a:",
        mergedDetails
      );
      setFieldValue("detallePagos", mergedDetails);
    } else {
      console.log(
        "[useSyncDetalles] La lista final es igual a la actual. No se actualiza."
      );
    }
    // Marcar que ya se realizó la sincronización inicial.
    initialSyncDone.current = true;
  }, [alumnoData, setFieldValue, values.autoRemoved]);
};
