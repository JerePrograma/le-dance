import { useEffect } from "react";
import { useFormikContext } from "formik";
import type { CobranzasFormValues, DeudasPendientesResponse } from "../../types/types";
import isEqual from "lodash/isEqual";

export const useSyncDetalles = (deudaData: DeudasPendientesResponse) => {
  const { values, setFieldValue } = useFormikContext<CobranzasFormValues>();

  // Calcula los detalles autogenerados a partir de la deuda.
  const newAutoDetails = (() => {
    const autoFromPagos =
      deudaData.pagosPendientes?.flatMap((pago) =>
        pago.detallePagos?.map((det) => ({
          autoGenerated: true,
          id: det.id,
          concepto: det.concepto,
          valorBase: det.valorBase,
          importe: det.importe,
          aCobrar: det.aCobrar,
        })) || []
      ) || [];

    const autoFromMensualidades =
      deudaData.mensualidadesPendientes?.flatMap((mens) =>
        mens.totalPagar > 0
          ? [
            {
              autoGenerated: true,
              id: mens.id,
              concepto: mens.descripcion,
              valorBase: mens.valorBase,
              importe: mens.totalPagar,
              aCobrar: mens.totalPagar,
            },
          ]
          : []
      ) || [];

    return [...autoFromPagos, ...autoFromMensualidades];
  })();

  useEffect(() => {
    // Separamos los detalles manuales (los que NO son autogenerados)
    const manualDetails = values.detallePagos.filter(
      (detalle) => !detalle.autoGenerated
    );

    // Separamos los detalles autogenerados actuales
    const currentAutoDetails = values.detallePagos.filter(
      (detalle) => detalle.autoGenerated
    );

    // Filtramos los nuevos autogenerados que NO hayan sido removidos por el usuario.
    // (Suponemos que values.autoRemoved es un array de IDs removidos)
    const removedIds = new Set(values.autoRemoved || []);
    const filteredNewAuto = newAutoDetails.filter(
      (detalle) =>
        !removedIds.has(detalle.id) && Number(detalle.importe) !== 0
    );

    // Si los detalles autogenerados actuales difieren de los que se calculan,
    // actualizamos solo esa parte, manteniendo intactos los detalles manuales.
    if (!isEqual(currentAutoDetails, filteredNewAuto)) {
      const merged = [...manualDetails, ...filteredNewAuto];
      // Sólo actualizamos si hay diferencias reales en contenido
      if (!isEqual(merged, values.detallePagos)) {
        setFieldValue("detallePagos", merged);
      }
    }
    // NOTA: Se omite values.detallePagos en el array de dependencias porque la comparación
    // se realiza internamente entre la parte autogenerada; así evitamos que la actualización
    // se dispare por cambios en los manuales.
  }, [newAutoDetails, values.autoRemoved, setFieldValue, values.detallePagos]);
};
